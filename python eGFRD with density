




import numpy as np

def P_r_t(r, r0, D, t, t0, N, e):
    """
    確率密度関数 P(r,t|r0,t0)
    P = (4πDΔt)^(-3/2) * exp[-| (3/4π) * N * e |^(2/3) / (4DΔt)]
    """
    dt = t - t0
    if dt <= 0:
        raise ValueError("t must be greater than t0.")
    coef = 1.0 / ( (4 * np.pi * D * dt) ** (1.5) )
    exponent = - ( np.abs((3/(4*np.pi)) * N * e) ** (2/3) ) / (4 * D * dt)
    return coef * np.exp(exponent)


def edge_factor(out_edges, in_edges):
    """
    エッジ数からeを決定
    - 出方向（out_edges > 1）： e = 1 / out_edges
    - 入方向（in_edges > 1）：  e = in_edges
    - それ以外： e = 1
    """
    if out_edges > 1:
        return 1.0 / out_edges
    elif in_edges > 1:
        return float(in_edges)
    else:
        return 1.0


def diffusion_iteration(r, r0, D, t, t0, N_init, out_edges, in_edges, iterations=5):
    """
    濃度 N と P(r,t|r0,t0) を逐次的に更新する
    """
    e = edge_factor(out_edges, in_edges)
    N = N_init
    results = []

    for k in range(iterations):
        P = P_r_t(r, r0, D, t, t0, N, e)
        N_next = N * P
        results.append((k, N, P))
        N = N_next  # 次の濃度として更新
    
    return results


# ===== 使用例 =====
if __name__ == "__main__":
    r, r0 = 1.0, 0.0
    D = 1.0e-9      # 拡散係数 [m^2/s]
    t0 = 0.0
    t = 1.0         # 時間 [s]
    N_init = 1.0e6  # 初期濃度
    out_edges = 3   # 出方向のエッジ数
    in_edges = 1    # 入方向のエッジ数

    results = diffusion_iteration(r, r0, D, t, t0, N_init, out_edges, in_edges, iterations=5)

    print("反復回数 | N_k         | P(r,t|r0,t0)")
    print("-------------------------------------")
    for k, N, P in results:
        print(f"{k:4d}     | {N:.3e} | {P:.3e}")
